# Django tutorial

django 프레임워크는 가상환경에서 사용하는 것을 추천한다. django 버전관리 때문!  

## django 프로젝트 생성  

django 프로젝트를 생성하기 위해서 프로젝트를 생성할 디렉터리에서 다음과 같이 명령어를 입력한다.  

```
django-admin startproject 프로젝트명
```  

생성된 프로젝트의 구조를 살펴보자면

- manage.py : 프로젝트와 상호작용하기 위한 커맨드 라인 유틸리티  

생성된 프로젝트와 같은 이름의 패키지가 생성되어 있다. 해당 패키지 내부를 보면  
- settings.py : 프로젝트의 환경 및 구성
- urls.py : URL 패턴 관리 (해당 프로젝트에 생성된 앱에 접근하기 위한 URL 패턴)
- asgi.py : ASGI 호환 웹 서버 진입점
- wsgi.py : WSGI 호환 웹 서버 진입점

## django 프로젝트 내부에 앱 생성  

프로젝트에는 앱을 생성하여 독립적으로 관리할 수 있다. 앱 생성은 manage.py 를 통해 진행한다. (앞으로도 많이 쓸 예정)  

```
python manage.py startapp 앱명
```  

앱을 생성하면 다음과 같이 구성되어 있다.  
- admin.py : 관리자 페이지를 관리한다. 이곳에서 모델을 관리자 페이지에 등록 및 커스텀이 가능하다.
- app.py  
- models.py : 해당 앱에 포함될 테이블을 설계하는 곳이다.
- test.py  
- urls.py (따로 생성해야 한다.) : 뷰에 매핑할 url 패턴을 작성하는 곳이다.
- views.py : 해당 앱의 url 패턴에 매핑될 뷰들을 작성하는 곳이다. 여기서 템플릿을 사용해 뷰(로직)로부터 디자인을 분리할 수 있다.
- migrations/ : python manage.py makemigrations [앱명] 을 통해 테이블의 변동사항을 만들고, python manage.py migrate [앱명]을 통해 변동사항을 commit한다.

### [참고] 관리자 페이지 커스텀
```
from django.contrib import admin

class SIGPostTable(admin.ModelAdmin):
    list_display = (
        'sig_cd',
        'sig_eng_nm',
        'sig_kor_nm',
    )

    list_display_links = (
        'sig_cd',
    )
    
admin.site.register(SIG,SIGPostTable)    
```  

위 코드처럼 단순히 register를 하는게 아니라 커스텀된 형태를 두번째 인자로 줄 수 있다.  
list_display는 어떤 필드가 보여질 것인지,  
list_display_links는 어떤 필드를 클릭하면 세부사항 링크를 걸지 선택할 수 있다.  
이 밖에도 다른 속성들이 많으니 직접 검색해보면 된다.  

### [참고] Migration
```
python manage.py makemigration [앱명]
```  
명령어를 실행하면 다음과 같이 마이그레이션 파일이 생성된다.  

e.g)  
```
# Generated by Django 3.1.3 on 2020-11-26 01:18

from django.db import migrations, models


class Migration(migrations.Migration):

    dependencies = [
        ('dbmanage', '0002_delete_info'),
    ]

    operations = [
        migrations.CreateModel(
            name='Info',
            fields=[
                ('receipt_no', models.IntegerField(primary_key=True, serialize=False)),
                ('pipe_length', models.FloatField()),
                ('exploration', models.FloatField()),
                ('measurement', models.FloatField()),
                ('non_exploration', models.FloatField()),
                ('map_scale', models.CharField(max_length=1000)),
            ],
        ),
    ]

```  

operations를 확인해보면 해당 마이그레이션 파일에서 어떤 연산을 수행할지 정보가 적혀져 있다. 다음의 코드에서는 새로운 모델(테이블)을 생성하는 CreateModel() 메소드가 사용되었다. 이 밖에도 DeleteModel(), Addfield()등 다양한 메소드들이 있으니 검색해보면 된다.  

Tip)  
```
python manage.py makemigrations --empty [앱명]
```  
--empty 옵션을 주게되면 operations가 비어있는 마이그레이션 파일이 생성된다. 여기다가 직접 operations를 작성하여 migrate를 해도된다. (능력이 된다면 ㅋ)  

## DB 설정  
루트 디렉터리의 setting.py를 통해 사용자가 원하는 데이터베이스를 선택할 수 있다.  

```
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}
```  

django는 기본적으로 sqlite3가 내장되어 있다.  
초기에 프로젝트를 생성하면 마이그레이트를 해주어야 한다. 사용자 테이블 등 기초적으로 필요한 테이블들을 초기화하기 위함이다.  

```
python manage.py migrate
```  

## django 프로젝트에 앱 등록  
django 프로젝트에서 앱만 생성했다고 끝나는 것이 아니다. 생성한 앱은 **프로젝트에 등록**을 해줘야 한다.  

```
INSTALLED_APPS = [
    'polls.apps.PollsConfig',
    ...
]
```

## 앱 내부에 모델 설계  

## 관리자 계정 생성  
관리자 계정을 생성하기 위해 최초로 django서버에 필요한 기본 테이블들을 초기화시켜야 한다.

```
python manage.py migrate
```

여러 테이블들이 자동으로 생성된 뒤에 관리자 계정을 생성하는 명령어를 실행한다.

```
python manage.py createsuperuser
```

## 서버 구동  
서버를 구동할 때에는 manage.py 인터페이스를 통해 실행한다.

```
python manage.py runserver [IP 주소][PORT 번호]
```

## 관리자 페이지에 모델 등록  

## view 작성  
view를 작성하기 이전에 장고의 **MTV(Model-View-Template) 패턴**에 대해 간단하게 짚고 넘어가겠다. 
Spring 프레임워크에는 MVC(Model-View-Controller)가 있다. 여기서 View는 사용자에게 보여지는 면이라고 이해하면 쉽다. View에게 사용자의 입력이 주어지면, View는 Controller에게 사용자의 입력을 전달한다. Controller는 입력받은 정보를 토대로 Model을 수정한다. 수정이 반영된 내용은 View에 다시 보여지게 된다.  
MTV패턴은 MVC패턴의 django버전이라고 생각하면 된다. Model=Model, View=Controller, Controller=Template  

우리는 이중에서 View를 작성할 것이다. View를 작성하기 위해서는 생성된 앱 내에 views.py에서 작성할 수 있다.  

```
from django.shortcuts import render

# Create your views here.
```  

보다시피 처음에는 아무것도 작성되어 있지 않다. 이곳에는 function-based view 혹은 class-based view를 작성할 수 있다. class-based view를 작성할 때에는 View 클래스를 상속해주어야 하며 url을 매핑할 때에는 as_view() 메소드를 사용해야 한다. 이 부분에 대해서는 URLConf에서 다루겠다. 다음과 같이 뷰를 작성해보자.  

```
from django.shortcuts import render, get_object_or_404
from django.http import HttpResponseRedirect
from django.urls import reverse
from django.views import generic
from django.utils import timezone

from .models import Question, Choice

# Create your views here.
# class-based view
class IndexView(generic.ListView):
    template_name = 'polls/index.html'
    context_object_name = 'latest_question_list'

    def get_queryset(self):
        # return Question.objects.order_by('-pub_date')[:5]
        return Question.objects.filter(pub_date__lte=timezone.now()).order_by('-pub_date')[:5]

# class-based view
class DetailView(generic.DetailView):
    model = Question
    template_name = 'polls/detail.html'

    def get_queryset(self):
        return Question.objects.filter(pub_date__lte=timezone.now())

# class-based view
class ResultsView(generic.DetailView):
    model = Question
    template_name = 'polls/results.html'

# function-based view
def vote(request, question_id):
    question = get_object_or_404(Question, pk=question_id)
    try:
        selected_choice = question.choice_set.get(pk=request.POST['choice'])
    except (KeyError, Choice.DoesNotExist):
        # Redisplay the question voting form.
        return render(request, 'polls/detail.html', {
            'question': question,
            'error_message': "You didn't select a choice.",
        })
    else:
        selected_choice.votes += 1
        selected_choice.save()
        return HttpResponseRedirect(reverse('polls:results', args=(question.id,)))

```  

위의 예제에서는 class-based view와 function-based view를 같이 쓴 views.py이다. class-based view는 제네릭 뷰를 상속받았다. 제네릭 뷰를 사용하지 않아도 상관없다. 제네릭 뷰를 사용한 이유는 많이 사용되는 뷰가 구현이 되어 있기 때문이다. 보충설명을 하자면.. (설명충 빙의중..)  

- get_queryset() : 해당 메소드는 제네릭 뷰의 오버라이딩 메소드이며 리턴값은 컨텍스트로써 템플릿에 전달된다.  
- context_object_name : get_queryset()에서 리턴값 (컨텍스트 객체)에 이름을 붙인다. 이것은 템플릿 작성에서 자세히 보겠다.  

## URLConf 설정  
뷰를 작성했으면 url을 매핑해주어야 한다. 해당 url로 뷰를 요청해 하니까! 잔말 하지않고 바로 코드리뷰를 하겠다.  

```
from django.urls import path

from . import views

# 네임스페이스 설정 - html의 url 템플릿 태그에 다른 앱들과 구분하기 위해 사용된다.
app_name = 'polls'

urlpatterns = [
    path('', views.IndexView.as_view(), name='index'),
    path('<int:pk>/', views.DetailView.as_view(), name='detail'),
    path('<int:pk>/results/', views.ResultsView.as_view(), name='results'),
    path('<int:question_id>/vote/', views.vote, name='vote'),
]

```  

app_name에 네임스페이싱을 한다. (템플릿에서 참조하기 쉽게 하려고..) 그리고 각 path()의 인자에 대해서 설명해주겠다!  
첫 번째 인자는 url 패턴이다. 해당 패턴을 호스트 url뒤에 적어주면 해당 뷰를 요청한다.  
두 번째 인자는 어떤 뷰를 매핑할지 적어준다. class-based view는 딱 보면 다른거 알겠쥬?  
세 번째 뷰는 해당 path에 네임스페이싱을 한 것이다. 이 또한 템플릿에서 참조가 쉬워지는 장점이 있다.  
